name: Deploy FrostLine

on:
  workflow_dispatch:

permissions:
  contents: read

jobs:
  deploy:
    runs-on: ubuntu-latest
    env:
      SSH_HOST: ${{ secrets.SSH_HOST }}
      SSH_USER: ${{ secrets.SSH_USER }}
      SSH_PORT: ${{ secrets.SSH_PORT }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Validate required secrets
        run: |
          set -euo pipefail
          test -n "${{ secrets.SSH_KEY }}"       || { echo "::error::SSH_KEY is empty"; exit 1; }
          test -n "${SSH_HOST}"                  || { echo "::error::SSH_HOST is empty"; exit 1; }
          test -n "${SSH_USER}"                  || { echo "::error::SSH_USER is empty"; exit 1; }
          test -n "${SSH_PORT}"                  || { echo "::error::SSH_PORT is empty"; exit 1; }
          test -n "${{ secrets.DATABASE_URL }}"  || { echo "::error::DATABASE_URL is empty"; exit 1; }
          test -n "${{ secrets.RSR_USERNAME }}"  || { echo "::error::RSR_USERNAME (FTP) is empty"; exit 1; }
          test -n "${{ secrets.RSR_PASSWORD }}"  || { echo "::error::RSR_PASSWORD (FTP) is empty"; exit 1; }

      - name: Start ssh-agent (load private key)
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_KEY }}

      - name: Add host to known_hosts
        run: |
          set -euo pipefail
          mkdir -p ~/.ssh
          ssh-keyscan -p "$SSH_PORT" -H "$SSH_HOST" >> ~/.ssh/known_hosts

      - name: Smoke test SSH
        run: |
          set -euo pipefail
          ssh -o BatchMode=yes -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" 'echo ok && whoami && hostname'

      - name: Write env and restart PM2 (safe, idempotent)
        env:
          # Required
          DATABASE_URL:                  ${{ secrets.DATABASE_URL }}
          RSR_USERNAME:                  ${{ secrets.RSR_USERNAME }}
          RSR_PASSWORD:                  ${{ secrets.RSR_PASSWORD }}

          # Recommended defaults (overridable)
          RSR_FTP_HOST:                  ${{ secrets.RSR_FTP_HOST }}
          RSR_FTP_PORT:                  ${{ secrets.RSR_FTP_PORT }}
          RSR_FTPS:                      ${{ secrets.RSR_FTPS }}

          # RSR “Standard” (API/feed) – distinct from FTP (optional)
          RSR_STANDARD_USERNAME:         ${{ secrets.RSR_STANDARD_USERNAME }}
          RSR_STANDARD_PASSWORD:         ${{ secrets.RSR_STANDARD_PASSWORD }}

          # Optional integrations
          AUTHORIZE_NET_API_LOGIN_ID:    ${{ secrets.AUTHORIZE_NET_API_LOGIN_ID }}
          AUTHORIZE_NET_TRANSACTION_KEY: ${{ secrets.AUTHORIZE_NET_TRANSACTION_KEY }}
          SENDGRID_API_KEY:              ${{ secrets.SENDGRID_API_KEY }}
          ALGOLIA_APP_ID:                ${{ secrets.ALGOLIA_APP_ID }}
          ALGOLIA_ADMIN_API_KEY:         ${{ secrets.ALGOLIA_ADMIN_API_KEY }}
        run: |
          set -euo pipefail

          # Ensure remote folder exists (private perms)
          ssh -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" 'install -d -m 700 /root/pm2'

          # --- Build a temp .env locally (masked in logs) ---
          envfile="$(mktemp)"; umask 077
          {
            printf 'PORT=5000\n'
            printf 'NODE_ENV=production\n'
            printf 'DATABASE_URL=%s\n' "$DATABASE_URL"
            # --- RSR FTPS (explicit TLS on 2222) ---
            printf 'RSR_FTP_HOST=%s\n' "${RSR_FTP_HOST:-ftps.rsrgroup.com}"
            printf 'RSR_FTP_PORT=%s\n' "${RSR_FTP_PORT:-2222}"
            printf 'RSR_FTPS=%s\n'     "${RSR_FTPS:-1}"
            # FTP creds ONLY (dealer login)
            printf 'RSR_USERNAME=%s\n' "$RSR_USERNAME"
            printf 'RSR_PASSWORD=%s\n' "$RSR_PASSWORD"
            # --- RSR "Standard" feed/API creds (separate from FTP) ---
            if [ -n "${RSR_STANDARD_USERNAME:-}" ]; then printf 'RSR_STANDARD_USERNAME=%s\n' "$RSR_STANDARD_USERNAME"; fi
            if [ -n "${RSR_STANDARD_PASSWORD:-}" ]; then printf 'RSR_STANDARD_PASSWORD=%s\n' "$RSR_STANDARD_PASSWORD"; fi
            # Optional integrations
            if [ -n "${AUTHORIZE_NET_API_LOGIN_ID:-}" ];    then printf 'AUTHORIZE_NET_API_LOGIN_ID=%s\n' "$AUTHORIZE_NET_API_LOGIN_ID"; fi
            if [ -n "${AUTHORIZE_NET_TRANSACTION_KEY:-}" ]; then printf 'AUTHORIZE_NET_TRANSACTION_KEY=%s\n' "$AUTHORIZE_NET_TRANSACTION_KEY"; fi
            if [ -n "${SENDGRID_API_KEY:-}" ];              then printf 'SENDGRID_API_KEY=%s\n' "$SENDGRID_API_KEY"; fi
            if [ -n "${ALGOLIA_APP_ID:-}" ];                then printf 'ALGOLIA_APP_ID=%s\n' "$ALGOLIA_APP_ID"; fi
            if [ -n "${ALGOLIA_ADMIN_API_KEY:-}" ];         then printf 'ALGOLIA_ADMIN_API_KEY=%s\n' "$ALGOLIA_ADMIN_API_KEY"; fi
          } >"$envfile"

          # Ship env file
          scp -P "$SSH_PORT" "$envfile" "$SSH_USER@$SSH_HOST:/root/pm2/frostline.env"
          rm -f "$envfile"

          # --- Create the remote restart script locally (no heredocs) ---
          restart="$(mktemp)"; umask 077
          printf '%s\n' '#!/usr/bin/env bash' >> "$restart"
          printf '%s\n' 'set -euo pipefail' >> "$restart"
          printf '%s\n' 'set +H' >> "$restart"
          printf '%s\n' 'chmod 600 /root/pm2/frostline.env' >> "$restart"
          printf '%s\n' 'set -a; . /root/pm2/frostline.env; set +a' >> "$restart"

          # ---- Parse DATABASE_URL into parts (user, pass, host, db) ----
          printf '%s\n' 'DBURL="$DATABASE_URL"' >> "$restart"
          printf '%s\n' 'DB_USER=$(printf "%s" "$DBURL" | sed -n '"'"'s~^[a-zA-Z0-9+]*://\([^:]*\):.*$~\1~p'"'"')' >> "$restart"
          printf '%s\n' 'DB_PASS=$(printf "%s" "$DBURL" | sed -n '"'"'s~^[a-zA-Z0-9+]*://[^:]*:\([^@]*\)@.*$~\1~p'"'"')' >> "$restart"
          printf '%s\n' 'DB_HOST=$(printf "%s" "$DBURL" | sed -n '"'"'s~^[a-zA-Z0-9+]*://[^@]*@\([^:/?]*\).*~\1~p'"'"')' >> "$restart"
          printf '%s\n' 'DB_NAME=$(printf "%s" "$DBURL" | sed -n '"'"'s~^.*/\([^/?]*\).*$~\1~p'"'"')' >> "$restart"
          printf '%s\n' 'ESC_PASS=$(printf "%s" "$DB_PASS" | sed "s/'"'"'/'"'"'"'"'"'"'"'"'/g")' >> "$restart"

          # ---- Ensure role + DB exist, and password matches secret (self-heal) ----
          printf '%s\n' 'sudo -u postgres psql -v ON_ERROR_STOP=1 -tc "SELECT 1 FROM pg_roles WHERE rolname='\''$DB_USER'\''" | grep -q 1 || sudo -u postgres psql -v ON_ERROR_STOP=1 -c "CREATE ROLE \"$DB_USER\" LOGIN PASSWORD '\''$ESC_PASS'\'';"' >> "$restart"
          printf '%s\n' 'sudo -u postgres psql -v ON_ERROR_STOP=1 -c "ALTER ROLE \"$DB_USER\" WITH LOGIN PASSWORD '\''$ESC_PASS'\'';"' >> "$restart"
          printf '%s\n' 'sudo -u postgres psql -v ON_ERROR_STOP=1 -tc "SELECT 1 FROM pg_database WHERE datname='\''$DB_NAME'\''" | grep -q 1 || sudo -u postgres psql -v ON_ERROR_STOP=1 -c "CREATE DATABASE \"$DB_NAME\" OWNER \"$DB_USER\";"' >> "$restart"

          # ---- Connectivity check (now that creds are synced) ----
          printf '%s\n' 'PGPASSWORD="$DB_PASS" psql -h "$DB_HOST" -U "$DB_USER" -d "$DB_NAME" -Atqc "select 1" >/dev/null' >> "$restart"

          # ---- Best-effort backup (multiline, no parentheses in message) ----
          printf '%s\n' 'if command -v pg_dump >/dev/null 2>&1; then' >> "$restart"
          printf '%s\n' '  ts="$(date +%Y%m%d-%H%M%S)"' >> "$restart"
          printf '%s\n' '  install -d -m 700 /root/backups' >> "$restart"
          printf '%s\n' '  if ! PGPASSWORD="$DB_PASS" pg_dump -h "$DB_HOST" -U "$DB_USER" -d "$DB_NAME" --no-owner --format=custom -f "/root/backups/frostline-$ts.dump"; then' >> "$restart"
          printf '%s\n' '    echo "::warning::pg_dump failed - backup skipped"' >> "$restart"
          printf '%s\n' '  fi' >> "$restart"
          printf '%s\n' 'fi' >> "$restart"

          # ---- Restart app & persist ----
          printf '%s\n' 'cd /var/www/frostline' >> "$restart"
          printf '%s\n' 'pm2 restart frostline --update-env --cwd /var/www/frostline' >> "$restart"
          printf '%s\n' 'pm2 save' >> "$restart"

          # ---- Health checks ----
          printf '%s\n' 'ss -ltnp | grep -E ":5000\\b" >/dev/null || { echo "::error::app is not listening on :5000"; exit 1; }' >> "$restart"
          printf '%s\n' 'curl -fsSI http://127.0.0.1:5000/ | head -1' >> "$restart"
          printf '%s\n' 'if command -v nginx >/dev/null 2>&1; then curl -fsSI -H "Host: thegunfirm.com" http://127.0.0.1/ | head -1 || true; fi' >> "$restart"

          # ---- FTPS handshake trace from app logs ----
          printf '%s\n' 'pm2 logs frostline --lines 180 --nostream | egrep -i '"'"'Connecting FTPS|> USER|< 331|< 230|< 530|rsr|IM-QTY|FULL|download|insert|upsert|error'"'"' || true' >> "$restart"

          # ---- Kick a full RSR import (best-effort) ----
          printf '%s\n' 'pm2 trigger frostline rsr:full >/dev/null 2>&1 || curl -fsS -X POST http://127.0.0.1:5000/_internal/rsr/full >/dev/null 2>&1 || true' >> "$restart"

          # Ship & execute restart script
          scp -P "$SSH_PORT" "$restart" "$SSH_USER@$SSH_HOST:/root/pm2/restart.sh"
          rm -f "$restart"
          ssh -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" 'bash /root/pm2/restart.sh'
